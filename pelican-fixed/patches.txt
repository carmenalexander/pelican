--- pelican/__init__.py	(original)
+++ pelican/__init__.py	(refactored)
@@ -73,7 +73,7 @@
         self.plugins = self.settings['PLUGINS']
         for plugin in self.plugins:
             # if it's a string, then import it
-            if isinstance(plugin, basestring):
+            if isinstance(plugin, str):
                 logger.debug("Loading plugin `{0}' ...".format(plugin))
                 plugin = __import__(plugin, globals(), locals(), 'module')
 
@@ -247,7 +247,7 @@
     settings = read_settings(args.settings)
 
     cls = settings.get('PELICAN_CLASS')
-    if isinstance(cls, basestring):
+    if isinstance(cls, str):
         module, cls_name = cls.rsplit('.', 1)
         module = __import__(module)
         cls = getattr(module, cls_name)
@@ -287,15 +287,15 @@
                 except KeyboardInterrupt:
                     logger.warning("Keyboard interrupt, quitting.")
                     break
-                except Exception, e:
+                except Exception as e:
                     logger.warning(
                         "Caught exception \"{}\". Reloading.".format(e)
                     )
                     continue
         else:
             pelican.run()
-    except Exception, e:
-        logger.critical(unicode(e))
+    except Exception as e:
+        logger.critical(str(e))
 
         if (args.verbosity == logging.DEBUG):
             raise
--- pelican/contents.py	(original)
+++ pelican/contents.py	(refactored)
@@ -39,7 +39,7 @@
         local_metadata.update(metadata)
 
         # set metadata as attributes
-        for key, value in local_metadata.items():
+        for key, value in list(local_metadata.items()):
             setattr(self, key.lower(), value)
 
         # also keep track of the metadata attributes available
@@ -55,7 +55,7 @@
             else:
                 title = filename.decode('utf-8') if filename else self.title
                 self.author = Author(getenv('USER', 'John Doe'), settings)
-                logger.warning(u"Author of `{0}' unknown, assuming that his name is "
+                logger.warning("Author of `{0}' unknown, assuming that his name is "
                          "`{1}'".format(title, self.author))
 
         # manage languages
@@ -175,7 +175,7 @@
 
 class URLWrapper(object):
     def __init__(self, name, settings):
-        self.name = unicode(name)
+        self.name = str(name)
         self.slug = slugify(self.name)
         self.settings = settings
 
@@ -186,7 +186,7 @@
         return hash(self.name)
 
     def __eq__(self, other):
-        return self.name == unicode(other)
+        return self.name == str(other)
 
     def __str__(self):
         return str(self.name.encode('utf-8', 'replace'))
@@ -197,11 +197,11 @@
     def _from_settings(self, key):
         setting = "%s_%s" % (self.__class__.__name__.upper(), key)
         value = self.settings[setting]
-        if not isinstance(value, basestring):
-            logger.warning(u'%s is set to %s' % (setting, value))
+        if not isinstance(value, str):
+            logger.warning('%s is set to %s' % (setting, value))
             return value
         else:
-            return unicode(value).format(**self.as_dict())
+            return str(value).format(**self.as_dict())
 
     url = property(functools.partial(_from_settings, key='URL'))
     save_as = property(functools.partial(_from_settings, key='SAVE_AS'))
@@ -213,7 +213,7 @@
 
 class Tag(URLWrapper):
     def __init__(self, name, *args, **kwargs):
-        super(Tag, self).__init__(unicode.strip(name), *args, **kwargs)
+        super(Tag, self).__init__(str.strip(name), *args, **kwargs)
 
 
 class Author(URLWrapper):
@@ -224,7 +224,7 @@
     try:
         content.check_properties()
         return True
-    except NameError, e:
-        logger.error(u"Skipping %s: impossible to find informations about '%s'"\
+    except NameError as e:
+        logger.error("Skipping %s: impossible to find informations about '%s'"\
                 % (f, e))
         return False
--- pelican/generators.py	(original)
+++ pelican/generators.py	(refactored)
@@ -31,7 +31,7 @@
                 'output_path', 'markup')):
             setattr(self, item, args[idx])
 
-        for arg, value in kwargs.items():
+        for arg, value in list(kwargs.items()):
             setattr(self, arg, value)
 
         # templates cache
@@ -102,7 +102,7 @@
         for item in items:
             value = getattr(self, item)
             if hasattr(value, 'items'):
-                value = value.items()
+                value = list(value.items())
             self.context[item] = value
 
 
@@ -151,7 +151,7 @@
                                   feed_type='rss')
 
         if self.settings.get('TAG_FEED_ATOM') or self.settings.get('TAG_FEED_RSS'):
-            for tag, arts in self.tags.items():
+            for tag, arts in list(self.tags.items()):
                 arts.sort(key=attrgetter('date'), reverse=True)
                 if self.settings.get('TAG_FEED_ATOM'):
                     writer.write_feed(arts, self.context,
@@ -167,7 +167,7 @@
             for article in chain(self.articles, self.translations):
                 translations_feeds[article.lang].append(article)
 
-            for lang, items in translations_feeds.items():
+            for lang, items in list(translations_feeds.items()):
                 items.sort(key=attrgetter('date'), reverse=True)
                 writer.write_feed(items, self.context,
                                   self.settings['TRANSLATION_FEED'] % lang)
@@ -197,13 +197,13 @@
     def generate_tags(self, write):
         """Generate Tags pages."""
         tag_template = self.get_template('tag')
-        for tag, articles in self.tags.items():
+        for tag, articles in list(self.tags.items()):
             articles.sort(key=attrgetter('date'), reverse=True)
             dates = [article for article in self.dates if article in articles]
             write(tag.save_as, tag_template, self.context, tag=tag,
                 articles=articles, dates=dates,
                 paginated={'articles': articles, 'dates': dates},
-                page_name=u'tag/%s' % tag)
+                page_name='tag/%s' % tag)
 
     def generate_categories(self, write):
         """Generate category pages."""
@@ -213,7 +213,7 @@
             write(cat.save_as, category_template, self.context,
                 category=cat, articles=articles, dates=dates,
                 paginated={'articles': articles, 'dates': dates},
-                page_name=u'category/%s' % cat)
+                page_name='category/%s' % cat)
 
     def generate_authors(self, write):
         """Generate Author pages."""
@@ -223,7 +223,7 @@
             write(aut.save_as, author_template, self.context,
                 author=aut, articles=articles, dates=dates,
                 paginated={'articles': articles, 'dates': dates},
-                page_name=u'author/%s' % aut)
+                page_name='author/%s' % aut)
 
     def generate_drafts(self, write):
         """Generate drafts pages."""
@@ -261,8 +261,8 @@
                 exclude=self.settings['ARTICLE_EXCLUDES']):
             try:
                 content, metadata = read_file(f, settings=self.settings)
-            except Exception, e:
-                logger.warning(u'Could not process %s\n%s' % (f, str(e)))
+            except Exception as e:
+                logger.warning('Could not process %s\n%s' % (f, str(e)))
                 continue
 
             # if no category is set, use the name of the path as a category
@@ -299,8 +299,8 @@
             elif article.status == "draft":
                 self.drafts.append(article)
             else:
-                logger.warning(u"Unknown status %s for file %s, skipping it." %
-                               (repr(unicode.encode(article.status, 'utf-8')),
+                logger.warning("Unknown status %s for file %s, skipping it." %
+                               (repr(str.encode(article.status, 'utf-8')),
                                 repr(f)))
 
         self.articles, self.translations = process_translations(all_articles)
@@ -322,10 +322,10 @@
             for tag in getattr(article, 'tags', []):
                 tag_cloud[tag] += 1
 
-        tag_cloud = sorted(tag_cloud.items(), key=itemgetter(1), reverse=True)
+        tag_cloud = sorted(list(tag_cloud.items()), key=itemgetter(1), reverse=True)
         tag_cloud = tag_cloud[:self.settings.get('TAG_CLOUD_MAX_ITEMS')]
 
-        tags = map(itemgetter(1), tag_cloud)
+        tags = list(map(itemgetter(1), tag_cloud))
         if tags:
             max_count = max(tags)
         steps = self.settings.get('TAG_CLOUD_STEPS')
@@ -379,8 +379,8 @@
                 exclude=self.settings['PAGE_EXCLUDES']):
             try:
                 content, metadata = read_file(f)
-            except Exception, e:
-                logger.warning(u'Could not process %s\n%s' % (f, str(e)))
+            except Exception as e:
+                logger.warning('Could not process %s\n%s' % (f, str(e)))
                 continue
             signals.pages_generate_context.send(self, metadata=metadata )
             page = Page(content, metadata, settings=self.settings,
@@ -392,8 +392,8 @@
             elif page.status == "hidden":
                 hidden_pages.append(page)
             else:
-                logger.warning(u"Unknown status %s for file %s, skipping it." %
-                               (repr(unicode.encode(page.status, 'utf-8')),
+                logger.warning("Unknown status %s for file %s, skipping it." %
+                               (repr(str.encode(page.status, 'utf-8')),
                                 repr(f)))
 
         self.pages, self.translations = process_translations(all_pages)
@@ -468,7 +468,7 @@
             # print "Generating pdf for", obj.filename, " in ", output_pdf
             with open(obj.filename) as f:
                 self.pdfcreator.createPdf(text=f, output=output_pdf)
-            logger.info(u' [ok] writing %s' % output_pdf)
+            logger.info(' [ok] writing %s' % output_pdf)
 
     def generate_context(self):
         pass
@@ -476,7 +476,7 @@
     def generate_output(self, writer=None):
         # we don't use the writer passed as argument here
         # since we write our own files
-        logger.info(u' Generating PDF files...')
+        logger.info(' Generating PDF files...')
         pdf_path = os.path.join(self.output_path, 'pdf')
         if not os.path.exists(pdf_path):
             try:
@@ -509,15 +509,15 @@
                         target_dir)
 
         subprocess.call([self._lessc, less_file, target])
-        logger.info(u' [ok] compiled %s' % base)
+        logger.info(' [ok] compiled %s' % base)
 
     def generate_output(self, writer=None):
-        logger.info(u' Compiling less css')
+        logger.info(' Compiling less css')
 
         # store out compiler here, so it won't be evaulted on each run of
         # _compile
         lg = self.settings['LESS_GENERATOR']
-        self._lessc = lg if isinstance(lg, basestring) else 'lessc'
+        self._lessc = lg if isinstance(lg, str) else 'lessc'
 
         # walk static paths
         for static_path in self.settings['STATIC_PATHS']:
--- pelican/log.py	(original)
+++ pelican/log.py	(refactored)
@@ -9,7 +9,7 @@
 from logging import Formatter, getLogger, StreamHandler, DEBUG
 
 
-RESET_TERM = u'\033[0;m'
+RESET_TERM = '\033[0;m'
 
 COLOR_CODES = {
     'red': 31,
@@ -24,7 +24,7 @@
 def ansi(color, text):
     """Wrap text in an ansi escape sequence"""
     code = COLOR_CODES[color]
-    return u'\033[1;{0}m{1}{2}'.format(code, text, RESET_TERM)
+    return '\033[1;{0}m{1}{2}'.format(code, text, RESET_TERM)
 
 
 class ANSIFormatter(Formatter):
@@ -35,17 +35,17 @@
 
     def format(self, record):
         if record.levelname is 'INFO':
-            return ansi('cyan', '-> ') + unicode(record.msg)
+            return ansi('cyan', '-> ') + str(record.msg)
         elif record.levelname is 'WARNING':
-            return ansi('yellow', record.levelname) + ': ' + unicode(record.msg)
+            return ansi('yellow', record.levelname) + ': ' + str(record.msg)
         elif record.levelname is 'ERROR':
-            return ansi('red', record.levelname) + ': ' + unicode(record.msg)
+            return ansi('red', record.levelname) + ': ' + str(record.msg)
         elif record.levelname is 'CRITICAL':
-            return ansi('bgred', record.levelname) + ': ' + unicode(record.msg)
+            return ansi('bgred', record.levelname) + ': ' + str(record.msg)
         elif record.levelname is 'DEBUG':
-            return ansi('bggrey', record.levelname) + ': ' + unicode(record.msg)
+            return ansi('bggrey', record.levelname) + ': ' + str(record.msg)
         else:
-            return ansi('white', record.levelname) + ': ' + unicode(record.msg)
+            return ansi('white', record.levelname) + ': ' + str(record.msg)
 
 
 class TextFormatter(Formatter):
--- pelican/paginator.py	(original)
+++ pelican/paginator.py	(refactored)
@@ -37,7 +37,7 @@
         Returns a 1-based range of pages for iterating through within
         a template for loop.
         """
-        return range(1, self.num_pages + 1)
+        return list(range(1, self.num_pages + 1))
     page_range = property(_get_page_range)
 
 
--- pelican/readers.py	(original)
+++ pelican/readers.py	(refactored)
@@ -20,9 +20,9 @@
 
 
 _METADATA_PROCESSORS = {
-    'tags': lambda x, y: [Tag(tag, y) for tag in unicode(x).split(',')],
+    'tags': lambda x, y: [Tag(tag, y) for tag in str(x).split(',')],
     'date': lambda x, y: get_date(x),
-    'status': lambda x, y: unicode.strip(x),
+    'status': lambda x, y: str.strip(x),
     'category': Category,
     'author': Author,
 }
@@ -134,7 +134,7 @@
         content = md.convert(text)
 
         metadata = {}
-        for name, value in md.Meta.items():
+        for name, value in list(md.Meta.items()):
             name = name.lower()
             metadata[name] = self.process_metadata(name, value[0])
         return content, metadata
--- pelican/rstdirectives.py	(original)
+++ pelican/rstdirectives.py	(refactored)
@@ -30,9 +30,9 @@
             # no lexer found - use the text one instead of an exception
             lexer = TextLexer()
         # take an arbitrary option if more than one is given
-        formatter = self.options and VARIANTS[self.options.keys()[0]] \
+        formatter = self.options and VARIANTS[list(self.options.keys())[0]] \
                     or DEFAULT
-        parsed = highlight(u'\n'.join(self.content), lexer, formatter)
+        parsed = highlight('\n'.join(self.content), lexer, formatter)
         return [nodes.raw('', parsed, format='html')]
 
 directives.register_directive('code-block', Pygments)
--- pelican/settings.py	(original)
+++ pelican/settings.py	(refactored)
@@ -50,8 +50,8 @@
                    'CATEGORY_SAVE_AS': 'category/{slug}.html',
                    'TAG_URL': 'tag/{slug}.html',
                    'TAG_SAVE_AS': 'tag/{slug}.html',
-                   'AUTHOR_URL': u'author/{slug}.html',
-                   'AUTHOR_SAVE_AS': u'author/{slug}.html',
+                   'AUTHOR_URL': 'author/{slug}.html',
+                   'AUTHOR_SAVE_AS': 'author/{slug}.html',
                    'RELATIVE_URLS': True,
                    'DEFAULT_LANG': 'en',
                    'TAG_CLOUD_STEPS': 4,
@@ -128,7 +128,7 @@
     # if locales is not a list, make it one
     locales = settings['LOCALE']
 
-    if isinstance(locales, basestring):
+    if isinstance(locales, str):
         locales = [locales]
 
     # try to set the different locales, fallback on the default.
--- pelican/utils.py	(original)
+++ pelican/utils.py	(refactored)
@@ -47,12 +47,12 @@
     Took from django sources.
     """
     value = Markup(value).striptags()
-    if type(value) == unicode:
+    if isinstance(value, str):
         import unicodedata
         from unidecode import unidecode
-        value = unicode(unidecode(value))
+        value = str(unidecode(value))
         value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore')
-    value = unicode(re.sub('[^\w\s-]', '', value).strip().lower())
+    value = str(re.sub('[^\w\s-]', '', value).strip().lower())
     return re.sub('[-\s]+', '-', value)
 
 
@@ -100,13 +100,13 @@
             try:
                 shutil.rmtree(file)
                 logger.debug("Deleted directory %s" % file)
-            except Exception, e:
+            except Exception as e:
                 logger.error("Unable to delete directory %s; %e" % file, e)
         elif os.path.isfile(file) or os.path.islink(file):
             try:
                 os.remove(file)
                 logger.debug("Deleted file/link %s" % file)
-            except Exception, e:
+            except Exception as e:
                 logger.error("Unable to delete file %s; %e" % file, e)
         else:
             logger.error("Unable to delete %s, file type unknown" % file)
@@ -128,7 +128,7 @@
     """
     length = int(num)
     if length <= 0:
-        return u''
+        return ''
     html4_singlets = ('br', 'col', 'link', 'base', 'img', 'param', 'area',
                       'hr', 'input')
 
@@ -202,10 +202,10 @@
     for slug, items in grouped_by_slugs:
         items = list(items)
         # find items with default language
-        default_lang_items = filter(attrgetter('in_default_lang'), items)
+        default_lang_items = list(filter(attrgetter('in_default_lang'), items))
         len_ = len(default_lang_items)
         if len_ > 1:
-            logger.warning(u'there are %s variants of "%s"' % (len_, slug))
+            logger.warning('there are %s variants of "%s"' % (len_, slug))
             for x in default_lang_items:
                 logger.warning('    %s' % x.filename)
         elif len_ == 0:
@@ -217,12 +217,9 @@
                 + 'content'
             logger.warning(msg)
         index.extend(default_lang_items)
-        translations.extend(filter(
-            lambda x: x not in default_lang_items,
-            items
-        ))
+        translations.extend([x for x in items if x not in default_lang_items])
         for a in items:
-            a.translations = filter(lambda x: x != a, items)
+            a.translations = [x for x in items if x != a]
     return index, translations
 
 
--- pelican/writers.py	(original)
+++ pelican/writers.py	(refactored)
@@ -1,5 +1,5 @@
 # -*- coding: utf-8 -*-
-from __future__ import with_statement
+
 
 import os
 import re
@@ -70,7 +70,7 @@
             max_items = len(elements)
             if self.settings['FEED_MAX_ITEMS']:
                 max_items = min(self.settings['FEED_MAX_ITEMS'], max_items)
-            for i in xrange(max_items):
+            for i in range(max_items):
                 self._add_item_to_the_feed(feed, elements[i])
 
             if filename:
@@ -122,7 +122,7 @@
                 pass
             with open(filename, 'w', encoding='utf-8') as f:
                 f.write(output)
-            logger.info(u'writing %s' % filename)
+            logger.info('writing %s' % filename)
 
         localcontext = context.copy()
         if relative_urls:
@@ -137,7 +137,7 @@
         if paginated:
             # pagination needed, init paginators
             paginators = {}
-            for key in paginated.iterkeys():
+            for key in paginated.keys():
                 object_list = paginated[key]
 
                 if self.settings.get('DEFAULT_PAGINATION'):
@@ -148,10 +148,10 @@
                     paginators[key] = Paginator(object_list, len(object_list))
 
             # generated pages, and write
-            for page_num in range(paginators.values()[0].num_pages):
+            for page_num in range(list(paginators.values())[0].num_pages):
                 paginated_localcontext = localcontext.copy()
                 paginated_name = name
-                for key in paginators.iterkeys():
+                for key in paginators.keys():
                     paginator = paginators[key]
                     page = paginator.page(page_num + 1)
                     paginated_localcontext.update(
@@ -210,7 +210,7 @@
         if context is None:
             return
         if hasattr(context, 'values'):
-            context = context.values()
+            context = list(context.values())
 
         for item in context:
             # run recursively on iterables
--- pelican/plugins/github_activity.py	(original)
+++ pelican/plugins/github_activity.py	(refactored)
@@ -65,7 +65,7 @@
         template
     """
 
-    if 'GITHUB_ACTIVITY_FEED' in gen.settings.keys():
+    if 'GITHUB_ACTIVITY_FEED' in list(gen.settings.keys()):
         gen.context['github_activity'] = gen.plugin_instance.fetch()
 
 
--- pelican/plugins/global_license.py	(original)
+++ pelican/plugins/global_license.py	(refactored)
@@ -15,8 +15,8 @@
 """
 
 def add_license(generator, metadata):
-    if 'license' not in metadata.keys()\
-        and 'LICENSE' in generator.settings.keys():
+    if 'license' not in list(metadata.keys())\
+        and 'LICENSE' in list(generator.settings.keys()):
             metadata['license'] = generator.settings['LICENSE']
 
 def register():
--- pelican/plugins/gravatar.py	(original)
+++ pelican/plugins/gravatar.py	(refactored)
@@ -25,12 +25,12 @@
 def add_gravatar(generator, metadata):
 
     #first check email
-    if 'email' not in metadata.keys()\
-        and 'AUTHOR_EMAIL' in generator.settings.keys():
+    if 'email' not in list(metadata.keys())\
+        and 'AUTHOR_EMAIL' in list(generator.settings.keys()):
             metadata['email'] = generator.settings['AUTHOR_EMAIL']
 
     #then add gravatar url
-    if 'email' in metadata.keys():
+    if 'email' in list(metadata.keys()):
         gravatar_url = "http://www.gravatar.com/avatar/" + \
                         hashlib.md5(metadata['email'].lower()).hexdigest()
         metadata["author_gravatar"] = gravatar_url
--- pelican/plugins/html_rst_directive.py	(original)
+++ pelican/plugins/html_rst_directive.py	(refactored)
@@ -52,7 +52,7 @@
     has_content = True
 
     def run(self):
-        html = u' '.join(self.content)
+        html = ' '.join(self.content)
         node = nodes.raw('', html, format='html')
         return [node]
 
--- pelican/plugins/initialized.py	(original)
+++ pelican/plugins/initialized.py	(refactored)
@@ -1,7 +1,7 @@
 from pelican import signals
 
 def test(sender):
-    print "%s initialized !!" % sender
+    print("%s initialized !!" % sender)
 
 def register():
     signals.initialized.connect(test)
--- pelican/plugins/related_posts.py	(original)
+++ pelican/plugins/related_posts.py	(refactored)
@@ -41,8 +41,8 @@
         if len(related_posts) < 1:
             return
 
-        relation_score = dict(zip(set(related_posts), map(related_posts.count,
-                              set(related_posts))))
+        relation_score = dict(list(zip(set(related_posts), list(map(related_posts.count,
+                              set(related_posts))))))
         ranked_related = sorted(relation_score, key=relation_score.get)
 
         metadata["related_posts"] = ranked_related[:5]
--- pelican/tools/pelican_import.py	(original)
+++ pelican/tools/pelican_import.py	(refactored)
@@ -90,7 +90,7 @@
                 else:
                     posts.append(line)
 
-    print("%i posts read." % len(posts))
+    print(("%i posts read." % len(posts)))
 
     for post in posts:
         fields = post.split('","')
@@ -140,13 +140,13 @@
         if len(tag) > 1:
             if int(tag[:1]) == 1:
                 newtag = tag.split('"')[1]
-                tags.append(unicode(BeautifulStoneSoup(newtag,convertEntities=BeautifulStoneSoup.HTML_ENTITIES )))
+                tags.append(str(BeautifulStoneSoup(newtag, convertEntities=BeautifulStoneSoup.HTML_ENTITIES )))
             else:
                 i=1
                 j=1
                 while(i <= int(tag[:1])):
-                    newtag = tag.split('"')[j].replace('\\','')
-                    tags.append(unicode(BeautifulStoneSoup(newtag,convertEntities=BeautifulStoneSoup.HTML_ENTITIES )))
+                    newtag = tag.split('"')[j].replace('\\', '')
+                    tags.append(str(BeautifulStoneSoup(newtag, convertEntities=BeautifulStoneSoup.HTML_ENTITIES )))
                     i=i+1
                     if j < int(tag[:1])*2:
                         j=j+2
@@ -233,7 +233,7 @@
                 # Replace newlines with paragraphs wrapped with <p> so
                 # HTML is valid before conversion
                 paragraphs = content.split('\n\n')
-                paragraphs = [u'<p>{0}</p>'.format(p) for p in paragraphs]
+                paragraphs = ['<p>{0}</p>'.format(p) for p in paragraphs]
                 new_content = ''.join(paragraphs)
 
                 fp.write(new_content)
@@ -253,7 +253,7 @@
                 elif rc > 0:
                     error = "Please, check your Pandoc installation."
                     exit(error)
-            except OSError, e:
+            except OSError as e:
                 error = "Pandoc execution failed: %s" % e
                 exit(error)
 
--- pelican/tools/pelican_quickstart.py	(original)
+++ pelican/tools/pelican_quickstart.py	(refactored)
@@ -48,9 +48,9 @@
         r = ''
         while True:
             if default:
-                r = raw_input('> {0} [{1}] '.format(question, default))
-            else:
-                r = raw_input('> {0} '.format(question, default))
+                r = input('> {0} [{1}] '.format(question, default))
+            else:
+                r = input('> {0} '.format(question, default))
 
             r = r.strip()
 
@@ -62,7 +62,7 @@
                     print('You must enter something')
             else:
                 if l and len(r) != l:
-                    print('You must enter a {0} letters long string'.format(l))
+                    print(('You must enter a {0} letters long string'.format(l)))
                 else:
                    break
 
@@ -72,11 +72,11 @@
         r = None
         while True:
             if default is True:
-                r = raw_input('> {0} (Y/n) '.format(question))
+                r = input('> {0} (Y/n) '.format(question))
             elif default is False:
-                r = raw_input('> {0} (y/N) '.format(question))
-            else:
-                r = raw_input('> {0} (y/n) '.format(question))
+                r = input('> {0} (y/N) '.format(question))
+            else:
+                r = input('> {0} (y/n) '.format(question))
 
             r = r.strip().lower()
 
@@ -96,9 +96,9 @@
         r = None
         while True:
             if default:
-                r = raw_input('> {0} [{1}] '.format(question, default))
-            else:
-                r = raw_input('> {0} '.format(question))
+                r = input('> {0} [{1}] '.format(question, default))
+            else:
+                r = input('> {0} '.format(question))
 
             r = r.strip()
 
@@ -131,18 +131,18 @@
 
     args = parser.parse_args()
 
-    print('''Welcome to pelican-quickstart v{v}.
+    print(('''Welcome to pelican-quickstart v{v}.
 
 This script will help you create a new Pelican-based website.
 
 Please answer the following questions so this script can generate the files needed by Pelican.
 
-    '''.format(v=__version__))
+    '''.format(v=__version__)))
 
     project = os.path.join(os.environ.get('VIRTUAL_ENV', '.'), '.project')
     if os.path.isfile(project):
         CONF['basedir'] = open(project, 'r').read().rstrip("\n")
-        print('Using project associated with current virtual environment. Will save to:\n%s\n' % CONF['basedir'])
+        print(('Using project associated with current virtual environment. Will save to:\n%s\n' % CONF['basedir']))
     else:
         CONF['basedir'] = os.path.abspath(ask('Where do you want to create your new web site?', answer=str, default=args.path))
 
@@ -178,13 +178,13 @@
 
     try:
         os.makedirs(os.path.join(CONF['basedir'], 'content'))
-    except OSError, e:
-        print('Error: {0}'.format(e))
+    except OSError as e:
+        print(('Error: {0}'.format(e)))
 
     try:
         os.makedirs(os.path.join(CONF['basedir'], 'output'))
-    except OSError, e:
-        print('Error: {0}'.format(e))
+    except OSError as e:
+        print(('Error: {0}'.format(e)))
 
     try:
         with open(os.path.join(CONF['basedir'], 'pelicanconf.py'), 'w') as fd:
@@ -192,8 +192,8 @@
                 template = string.Template(line)
                 fd.write(template.safe_substitute(CONF))
             fd.close()
-    except OSError, e:
-        print('Error: {0}'.format(e))
+    except OSError as e:
+        print(('Error: {0}'.format(e)))
 
     try:
         with open(os.path.join(CONF['basedir'], 'publishconf.py'), 'w') as fd:
@@ -201,8 +201,8 @@
                 template = string.Template(line)
                 fd.write(template.safe_substitute(CONF))
             fd.close()
-    except OSError, e:
-        print('Error: {0}'.format(e))
+    except OSError as e:
+        print(('Error: {0}'.format(e)))
 
     if mkfile:
         try:
@@ -211,8 +211,8 @@
                     template = string.Template(line)
                     fd.write(template.safe_substitute(CONF))
                 fd.close()
-        except OSError, e:
-            print('Error: {0}'.format(e))
+        except OSError as e:
+            print(('Error: {0}'.format(e)))
 
     if develop:
         try:
@@ -221,8 +221,8 @@
                     template = string.Template(line)
                     fd.write(template.safe_substitute(CONF))
                 fd.close()
-                os.chmod((os.path.join(CONF['basedir'], 'develop_server.sh')), 0755)
-        except OSError, e:
-            print('Error: {0}'.format(e))
-
-    print('Done. Your new project is available at %s' % CONF['basedir'])
+                os.chmod((os.path.join(CONF['basedir'], 'develop_server.sh')), 0o755)
+        except OSError as e:
+            print(('Error: {0}'.format(e)))
+
+    print(('Done. Your new project is available at %s' % CONF['basedir']))
--- pelican/tools/pelican_themes.py	(original)
+++ pelican/tools/pelican_themes.py	(refactored)
@@ -30,7 +30,7 @@
     """Print an error message and exits if an exit code is given"""
     sys.stderr.write(str(msg) + '\n')
     if die:
-        sys.exit((die if type(die) is int else 1))
+        sys.exit((die if isinstance(die, int) else 1))
 
 
 def main():
@@ -131,9 +131,9 @@
             t = os.path.basename(t)
         if l:
             if v:
-                print(t + (" (symbolic link to `" + l + "')"))
+                print((t + (" (symbolic link to `" + l + "')")))
             else:
-                print(t + '@')
+                print((t + '@'))
         else:
             print(t)
 
@@ -141,18 +141,18 @@
 def remove(theme_name, v=False):
     """Removes a theme"""
 
-    theme_name = theme_name.replace('/','')
+    theme_name = theme_name.replace('/', '')
     target = os.path.join(_THEMES_PATH, theme_name)
 
     if theme_name in _BUILTIN_THEMES:
         err(theme_name + ' is a builtin theme.\nYou cannot remove a builtin theme with this script, remove it by hand if you want.')
     elif os.path.islink(target):
         if v:
-            print('Removing link `' + target + "'")
+            print(('Removing link `' + target + "'"))
         os.remove(target)
     elif os.path.isdir(target):
         if v:
-            print('Removing directory `' + target + "'")
+            print(('Removing directory `' + target + "'"))
         shutil.rmtree(target)
     elif os.path.exists(target):
         err(target + ' : not a valid theme')
@@ -177,7 +177,7 @@
             install(path, v)
         else:
             if v:
-                print("Copying `{p}' to `{t}' ...".format(p=path, t=theme_path))
+                print(("Copying `{p}' to `{t}' ...".format(p=path, t=theme_path)))
             try:
                 shutil.copytree(path, theme_path)
 
@@ -186,13 +186,13 @@
                         for root, dirs, files in os.walk(theme_path):
                             for d in dirs:
                                 dname = os.path.join(root, d)
-                                os.chmod(dname, 0755)
+                                os.chmod(dname, 0o755)
                             for f in files:
                                 fname = os.path.join(root, f)
-                                os.chmod(fname, 0644)
-                except OSError, e:
+                                os.chmod(fname, 0o644)
+                except OSError as e:
                     err("Cannot change permissions of files or directory in `{r}':\n{e}".format(r=theme_path, e=str(e)), die=False)
-            except Exception, e:
+            except Exception as e:
                 err("Cannot copy `{p}' to `{t}':\n{e}".format(p=path, t=theme_path, e=str(e)))
 
 
@@ -209,10 +209,10 @@
             err(path + ' : already exists')
         else:
             if v:
-                print("Linking `{p}' to `{t}' ...".format(p=path, t=theme_path))
+                print(("Linking `{p}' to `{t}' ...".format(p=path, t=theme_path)))
             try:
                 os.symlink(path, theme_path)
-            except Exception, e:
+            except Exception as e:
                 err("Cannot link `{p}' to `{t}':\n{e}".format(p=path, t=theme_path, e=str(e)))
 
 
@@ -230,12 +230,12 @@
         if os.path.islink(path):
             if is_broken_link(path):
                 if v:
-                    print('Removing {0}'.format(path))
+                    print(('Removing {0}'.format(path)))
                 try:
                     os.remove(path)
-                except OSError, e:
-                    print('Error: cannot remove {0}'.format(path))
+                except OSError as e:
+                    print(('Error: cannot remove {0}'.format(path)))
                 else:
                     c+=1
 
-    print("\nRemoved {0} broken links".format(c))
+    print(("\nRemoved {0} broken links".format(c)))
